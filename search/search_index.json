{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":""},{"location":"index.html#flake8-custom-import-rules","title":"flake8-custom-import-rules","text":"<p>A <code>flake8</code> plugin that enforces custom import rules, allowing users to define and maintain clean and consistent import organization across their Python projects.</p> <p>This plugin takes advantage of <code>flake8</code> linting capabilities and provides set of flags that enable you to specify import restrictions, standalone packages and modules, and additional custom and project-level import rules. These flags can be used in conjunction with each other to provide granular control over your import rules. The use of these flags is highly dependent on the specific needs and coding standards of your project. They provide a means to enforce certain styles or practices, but may not be necessary or beneficial in all cases. It's important to consider the trade-offs and potential impacts before deciding to use these restrictions.</p> <p>There are two types of import rules that can be enforced by this plugin:</p> <ul> <li>Custom Import Rules (CIR) allow you to define and enforce     import rules for specific package and modules within your     project.</li> <li>Project Import Rules (PIR) allow you to define and enforce     import rules at a project level.</li> </ul>"},{"location":"index.html#motivation","title":"Motivation","text":"<p>This <code>flake8</code> plugin is extremely useful for enforcing custom import rules and maintaining a consistent import organization across Python projects. By allowing users to define specific restrictions, standalone packages, and import rules, this plugin helps to prevent unwanted dependencies and ensures a clear separation between high-level and low-level packages. Furthermore, it aids in managing lightweight packages by restricting them to import only from the Python standard library or third-party libraries, keeping them free from unnecessary dependencies.</p> <p>This plugin not only enhances code readability and maintainability but also encourages a modular architecture that is easier to understand, test, and debug. As a result, developers can effortlessly adhere to best practices, ensuring their projects remain clean, well-organized, and optimized for efficient collaboration.</p> <p>In today's digital age, with the prolific production of code at many organizations and the increasing number of contributors to various projects, one of the significant challenges we face is the maintainability and comprehensibility of code. Ensuring consistent and clean code is not merely an aesthetic or pedantic pursuit; it directly impacts the efficiency of onboarding new team members and the associated costs. Misunderstandings and inconsistencies in code can lead to miscommunication, errors, and increased time spent onboarding and training new staff. By enforcing custom import rules and maintaining a consistent import organization across Python projects, we can significantly mitigate these issues, streamlining the process of integrating new team members and maintaining the high quality and readability of our codebase.</p> <p>A <code>flake8</code> plugin that enforces custom import rules, allowing users to define and maintain clean and consistent import organization across their Python projects.</p>"},{"location":"index.html#installation","title":"Installation","text":"<p>Install from <code>pip</code> with:</p> <pre><code>pip install flake8-custom-import-rules\n</code></pre>"},{"location":"index.html#plugin-options-required-flags-options","title":"Plugin Options: Required Flags &amp; Options","text":"<p>The following flag is required to enable most of the plugin functionality:</p> <ul> <li>base-packages</li> </ul>"},{"location":"index.html#base-packages-option","title":"Base Packages Option","text":"<p>The <code>--base-packages</code> flag serves as a foundational configuration option within the tool, allowing users to explicitly define the primary packages that constitute their project. These identified packages are categorized as first-party, signifying the core elements that are actively being developed within the scope of the project itself.</p> <p>By specifying the base packages, users create a clear delineation between their main project components and external dependencies. This distinction assists in various operations, such as linting, dependency analysis, and code organization.</p> <p>For instance, if a user is developing a library named <code>my_library</code>, they would include <code>my_library</code> as a base package by configuring this flag. This inclusion ensures that the tool recognizes <code>my_library</code> as the reference package for imposing many of the rules the user is likely to define or enable, aligning its behavior with the user's development practices. As seen below:</p> <pre><code>[flake8]\nbase-packages = my_library,my_other_library\n</code></pre> <p>It's important to note that if the base-packages flag is not configured, the majority of functionality within the tool will be limited or disabled. This flag is instrumental in tailoring the plugin's behavior to the specific structure and needs of the project.</p> <p>That said, the project import rules (PIR) are not dependent on the base-packages flag, and can be used independently, therefore the base-packages flag is not set to as required within the <code>flake8</code> framework.</p>"},{"location":"index.html#plugin-options-custom-import-rules-cir","title":"Plugin Options: Custom Import Rules (CIR)","text":"<p>Custom Import Rules (CIR) allow you to define and enforce import rules for modules and packages within your project.</p>"},{"location":"index.html#restricted-packages-option","title":"Restricted Packages Option","text":"<p>The <code>--restricted-packages</code> flag allows you to specify high-level packages that should not be imported into any other packages within your project. This maintains the integrity of high-level packages, ensuring that they are not tightly coupled with other parts of the codebase.</p> <p>For example, if you have a high-level package like 'app' responsible for core functionality, you may want to prevent it from being imported into lower-level packages such as 'common', 'utils', 'core', etc. This can help avoid circular dependencies and preserve a clean architectural hierarchy.</p> <pre><code>[flake8]\nrestricted_packages = app\n</code></pre>"},{"location":"index.html#standard-library-only-imports-option","title":"Standard Library Only Imports Option","text":"<p>The <code>--std-lib-only</code> flag enables you to designate specific packages within your project that are restricted to importing only from the Python standard library. This maintains a lightweight footprint for those packages, ensuring they remain easily portable and free from third-party dependencies.</p> <p>For example, you might be developing a 'lightweight_package' meant to be used across various environments without the need for additional dependencies. By restricting this package to import only from the Python standard library, you can ensure its compatibility and ease of use.</p> <pre><code>[flake8]\nstd_lib_only = lightweight_package\n</code></pre>"},{"location":"index.html#project-only-imports-option","title":"Project Only Imports Option","text":"<p>The <code>--project-only</code> flag restricts specified modules and packages within your project to import solely from other packages developed as part of the project and the standard library. This ensures that the internal functionality is prioritized, and third-party dependencies are minimized.</p> <p>Consider a scenario where you want to maintain the integrity and independence of your project's core functionality. By using the <code>project-only</code> option, you can ensure that specific modules or packages rely exclusively on the internally developed code, reducing the risk of external dependencies and promoting a cohesive codebase.</p> <p>For example, if you have a package 'package_a' and you want to restrict it to only import from the local package and the project's top-level package, you can specify:</p> <pre><code>[flake8]\nproject_only = package_a\n</code></pre> <p>In this configuration, 'package_a' is limited to importing only from other packages defined within the project, fostering a controlled and self-contained development environment.</p>"},{"location":"index.html#base-package-only-imports-option","title":"Base Package Only Imports Option","text":"<p>The <code>--base-package-only</code> flag is a powerful tool for enforcing a hierarchical structure within your project. By specifying packages or modules with this flag, you ensure that they can only import from the project's root package. This centralizes the dependency flow and promotes a well-structured project design.</p> <p>Consider a complex project with multiple interdependent packages. You might want to ensure that certain packages rely solely on the root package to minimize potential conflicts and promote maintainability. The <code>base-package-only</code> option allows you to create this clear and organized dependency structure.</p> <p>For example, suppose you have a package named <code>package_h</code> that you want to restrict to only import from the top-level package of your project. You can specify this as follows:</p> <pre><code>[flake8]\nbase_package_only = my_base_package.package_h\n</code></pre> <p>In this configuration, 'package_h' can only import from <code>my_base_package</code>. Any attempt to import from other packages will be flagged by the linter. This ensures that <code>my_base_package</code> remains the central point of interaction, providing better control and clarity in the project's architecture.</p> <p>Now, let's consider another package, <code>my_second_package</code>. Suppose you want to ensure that <code>my_second_package</code> does not import any other packages specified in base-packages. This might be useful if 'my_second_package' is designed to be independent or if it contains functionality that should not be influenced by other parts of the project. You can specify this restriction as follows:</p> <pre><code>[flake8]\nbase_package_only = my_base_package.package_h, my_second_package\n\n</code></pre> <p>With this configuration, <code>my_second_package</code> is restricted from importing any other packages specified in base-packages. This ensures the independence of <code>my_second_package</code>, allowing it to function without being affected by changes in other parts of the project.</p>"},{"location":"index.html#first-party-only-imports-option","title":"First-Party Only Imports Option","text":"<p>The <code>--first-party-only</code> flag ensures that only first-party modules, i.e., those developed within the project, can be imported. This restriction includes all imports defined within the base packages, excluding the imports from its own root package.</p> <p>This control over imports can be highly beneficial in security-sensitive environments or in projects aiming to minimize external dependencies. By limiting the imports to first-party modules, you gain more control over the codebase and reduce potential risks associated with third-party dependencies.</p> <p>Consider a scenario where your project requires strict compliance with certain regulations or standards. By enforcing a first-party only import policy, you can ensure that all code is vetted and maintained within your organization, reducing potential legal or security concerns.</p> <p>To implement this restriction, you can specify:</p> <pre><code>[flake8]\nfirst_party_only = my_project.my_package\n</code></pre> <p>In this example, 'my_package' within 'my_project' will only be allowed to import modules developed as part of the project. Any attempt to import from outside the project will be flagged by the linter, helping to maintain the integrity and security of the codebase.</p>"},{"location":"index.html#third-party-only-imports-option","title":"Third-Party Only Imports Option","text":"<p>The <code>--third-party-only</code> flag is designed to enforce the use of only third-party modules in the specified packages or modules. This restriction prohibits the import of both standard library modules and project-specific modules, ensuring that only external libraries are utilized.</p> <p>Such a restriction can be particularly useful in scenarios where a system is designed to extend its functionality exclusively through third-party libraries. For instance, in a plugin system that relies on external extensions, this flag guarantees that only those third-party libraries are imported, excluding any standard or project-level modules.</p> <p>Unlike the <code>standalone-modules</code> rule, the <code>third-party-only</code> rule prevents even the importation of modules from within the specified package or module itself, further narrowing the scope of allowed imports.</p> <p>To apply this restriction, you can specify:</p> <pre><code>[flake8]\nthird_party_only = my_plugin_system.my_plugin\n</code></pre> <p>In this example, 'my_plugin' within 'my_plugin_system' will be restricted to importing only third-party modules. Any attempt to import from the standard library or from other modules within the project will be flagged by the linter. This ensures a strict adherence to the design principles of relying solely on third-party extensions, maintaining the integrity of the plugin system.</p>"},{"location":"index.html#standalone-modules-option","title":"Standalone Modules Option","text":"<p>The <code>--standalone-modules</code> flag is designed to allow specific packages or modules to import only from the standard library, the base package of the project, and third-party libraries, excluding any other first-party or project-level imports. This ensures that the specified standalone packages or modules operate independently of other parts of the project, yet they still have access to essential third-party libraries, the base package, and standard libraries.</p> <p>This option aids in maintainability and scalability, especially in complex projects where clear boundaries and modular design are essential. Standalone modules or packages can be used to encapsulate specific functionalities that don't require integration with the rest of the first-party code.</p> <p>Here's an example of how you can configure this rule:</p> <pre><code>[flake8]\nstandalone_modules = my_base_package.standalone_module\n</code></pre> <p>In this example, 'standalone_module' within 'my_base_package' is configured to import only from the standard library, the base package itself, and third-party libraries. Any attempt to import from other first-party packages or modules within the project will be flagged by the linter.</p> <p>It's worth noting the difference between the <code>standalone-modules</code> rule and the <code>third-party-only</code> rule. While both restrict project-specific imports, <code>standalone-modules</code> allows imports from within the standalone package or module itself, whereas <code>third-party-only</code> does not, further narrowing the scope of allowed imports.</p> <p>By employing the <code>standalone-modules</code> option, developers can ensure that certain parts of the application remain decoupled and self-contained, promoting a clean and organized code structure that can be more easily managed and expanded.</p>"},{"location":"index.html#custom-restrictions-option","title":"Custom Restrictions Option","text":"<p>The <code>--custom-restrictions</code> flag provides a powerful tool for managing and limiting specific import capabilities within your project. It enables you to precisely control the import behavior of individual packages or modules, ensuring that certain imports are restricted as per the project's requirements.</p> <p>This control is achieved by specifying a package or module, followed by a colon, and then listing the restricted imports, separated by additional colons. These restricted imports can range from other first-party packages within the project to standard library packages, or even third-party imports.</p> <p>Such granularity is particularly valuable in large or complex projects where managing dependencies and maintaining a clear structure can be challenging. For example, you may have <code>package_a</code> responsible for raw data cleaning and <code>package_b</code> for processing sensitive data. To avoid accidental leakage of raw data into <code>package_b</code>, you could apply restrictions to prevent <code>package_a</code> from importing <code>package_b</code> or any of its subpackages.</p> <p>The configuration might look like this:</p> <pre><code>[flake8]\ncustom-restrictions =\n    # Restrict `package_a` from importing `package_b` and `os`\n    my_base_package.package_a:my_base_package.package_b:os\n    # Restrict `module_x` from importing `module_y` and `pandas`\n    my_base_package.module_x:my_base_package.module_y:pandas\n</code></pre> <p>In the example above, specific restrictions are applied to <code>package_a</code> and <code>module_x</code>, preventing them from importing certain other packages or modules within the project, or even from the standard library or third-party libraries. Again, this is to provide a granular level of control over the import behavior of individual packages or modules, restricting imports from <code>pandas</code> or even <code>os</code> is not very likely within your own project, but there may reasons make these restrictions. This ensures that the intended separation and containment of functionality are preserved, enhancing the maintainability and security of the codebase.</p>"},{"location":"index.html#plugin-options-project-import-rules-pir","title":"Plugin Options: Project Import Rules (PIR)","text":"<p>Project Import Rules (PIR) allow you to define and enforce import rules at a project level.</p>"},{"location":"index.html#restrict-relative-imports","title":"Restrict Relative Imports","text":"<p>Relative imports in Python allow you to import modules or specific objects from modules within the same package hierarchy, using dots (<code>.</code>) to represent the relative path.</p> <p>By default, the <code>--restrict-relative-imports</code> flag is enabled, prohibiting the use of relative imports. Modules must instead utilize absolute imports, specifying the full path to the target module, starting from the top-level package.</p> <p>To enforce this restriction and disable relative imports for your project, you can configure the following setting:</p> <pre><code>[flake8]\nrestrict_relative_imports = True\n</code></pre> <p>With this configuration, any relative imports encountered in your project will be flagged by the linter, guiding you to use absolute imports instead.</p>"},{"location":"index.html#restrict-local-scope-imports","title":"Restrict Local Scope Imports","text":"<p>Local scope imports refer to the practice of importing modules or specific objects within a confined scope, such as inside a function or method. While this can allow for more granular control over imports, it may lead to code that is less clear and consistent.</p> <p>The <code>--restrict-local-scope-imports</code> flag is designed to prevent such imports, enforcing that all imports occur at the top-level of the file. By centralizing imports, it promotes code clarity and consistency across the project.</p> <p>This restriction is turned on by default, meaning that any local scope imports will be flagged by the linter. If you wish to adhere to this best practice, ensure that all imports are declared at the top-level of your files, rather than within specific functions or methods.</p> <pre><code>[flake8]\nrestrict_local_scope_imports = True\n</code></pre> <p>With this configuration, the linter will guide you to organize your imports at the top-level, fostering a more readable and maintainable codebase.</p>"},{"location":"index.html#restrict-conditional-imports","title":"Restrict Conditional Imports","text":"<p>Conditional imports in Python refer to the practice of importing modules or specific symbols based on certain conditions or runtime logic. These imports can be found inside control structures like <code>if</code> statements.</p> <p>The <code>--restrict-conditional-imports</code> flag aims to limit the use of these imports, as they can potentially lead to inconsistent behavior. The importation of a module might depend on varying runtime conditions, leading to unexpected outcomes.</p> <p>This restriction is turned off by default, allowing for conditional imports. However, considering the potential risks and complexities, you may choose to enable this flag:</p> <pre><code>[flake8]\nrestrict_conditional_imports = True\n</code></pre> <p>By restricting conditional imports, you can foster a more predictable and manageable codebase.</p>"},{"location":"index.html#restrict-dynamic-imports","title":"Restrict Dynamic Imports","text":"<p>Dynamic imports in Python involve importing modules or specific symbols within a function or method. Such imports can be challenging to track and may result in unexpected behavior, as the availability of a module may hinge on the specific execution path.</p> <p>The <code>--restrict-dynamic-imports</code> flag is designed to prevent these imports, promoting a more stable and transparent code structure. This restriction is turned on by default, emphasizing the importance of predictability in code execution.</p> <pre><code>[flake8]\nrestrict_dynamic_imports = True\n</code></pre> <p>By enforcing this rule, you encourage a more coherent and traceable import structure, enhancing code reliability.</p>"},{"location":"index.html#restrict-private-imports","title":"Restrict Private Imports","text":"<p>Private modules in Python are typically those that begin with an underscore (<code>_</code>). These modules are meant for internal use within a package, and importing them can lead to instability, as they may change without notice.</p> <p>The <code>--restrict-private-imports</code> flag limits the import of private modules, preserving the stability of your code. Although Python doesn't truly enforce private access, this flag provides a layer of protection. It is turned on by default, reflecting a best-practice approach.</p> <pre><code>[flake8]\nrestrict_private_imports = True\n</code></pre> <p>By restricting the import of private modules, you align with community conventions and safeguard your code from potential instabilities related to internal package changes.</p>"},{"location":"index.html#restrict-wildcard-imports","title":"Restrict Wildcard Imports","text":"<p>Wildcard imports in Python, expressed as <code>from module import *</code>, bring all symbols from a module into the current namespace. While convenient, these imports can lead to confusion, as it becomes unclear which names are being imported. Furthermore, they may inadvertently overwrite existing names.</p> <p>The <code>--restrict-wildcard-imports</code> flag is designed to prohibit these imports, fostering greater code clarity and safety. This flag is turned on by default, reflecting a standard practice in code organization.</p> <pre><code>[flake8]\nrestrict_wildcard_imports = True\n</code></pre> <p>By restricting wildcard imports, you promote a more transparent and manageable code structure, enhancing maintainability.</p>"},{"location":"index.html#restrict-aliased-imports","title":"Restrict Aliased Imports","text":"<p>Aliased imports, such as <code>import numpy as np</code>, allow modules or specific symbols to be imported under a different name. While often convenient, especially for widely recognized aliases, they can sometimes cause confusion, particularly with non-standard or unconventional aliases.</p> <p>The <code>--restrict-aliased-imports</code> flag aims to limit this practice, although it is turned off by default, acknowledging the common usage of standard aliases.</p> <pre><code>[flake8]\nrestrict_aliased_imports = False\n</code></pre> <p>While aliasing has its benefits, particularly with widely accepted conventions, this flag provides an option for those who prefer to maintain a stricter naming policy.</p>"},{"location":"index.html#restrict-future-imports","title":"Restrict Future Imports","text":"<p>Future imports in Python, expressed as <code>from __future__ import</code>, enable features that will become standard in upcoming versions of Python. While they facilitate forward compatibility, their use might also introduce confusion or compatibility challenges.</p> <p>The <code>--restrict-future-imports</code> flag allows you to limit the use of future imports, providing a layer of control. This flag is turned off by default, allowing flexibility in adopting future language features.</p> <pre><code>[flake8]\nrestrict_future_imports = False\n</code></pre> <p>By offering this restriction, you can ensure that future imports are used judiciously and aligned with your project's needs and standards.</p>"},{"location":"index.html#restrict-imports-from-init-files","title":"Restrict Imports From Init Files","text":"<p>Importing from <code>__init__.py</code> files can sometimes lead to confusing circular dependencies or unexpected behavior. These files typically serve to initialize a package, and importing from them may complicate the package structure.</p> <p>The <code>--restrict-init-imports</code> flag is designed to prevent these imports, promoting cleaner code organization. This restriction is turned on by default.</p> <pre><code>[flake8]\nrestrict_init_imports = True\n</code></pre> <p>By enforcing this rule, you can maintain a clear separation between initialization and functional code, enhancing code clarity and maintainability.</p>"},{"location":"index.html#restrict-import-from-main-files","title":"Restrict Import From Main Files","text":"<p>Importing from <code>__main__.py</code> files is generally not considered best practice in Python development, as previously explained. The <code>__main__.py</code> file is meant to define the entry point for package execution, not to house reusable functions or classes.</p> <p>The <code>--restrict-main-imports</code> flag restricts these imports, aligning with best practices. This flag is turned on by default.</p> <pre><code>[flake8]\nrestrict_main_imports = True\n</code></pre> <p>By adhering to this restriction, you ensure that your codebase follows a conventional structure, minimizing potential confusion and maintenance challenges.</p>"},{"location":"index.html#restrict-test-imports","title":"Restrict Test Imports","text":"<p>Test imports refer to imports from test files or the tests directory. While these imports can be useful for testing purposes, they may inadvertently create dependencies between testing and production code. This entanglement can complicate code maintenance and lead to potential issues.</p> <p>The <code>--restrict-test-imports</code> flag restricts these imports, enforcing a separation between testing and production code. This restriction is turned on by default.</p> <pre><code>[flake8]\nrestrict_test_imports = True\n</code></pre> <p>By employing this flag, you ensure a clean demarcation between testing and main code, enhancing the modularity and maintainability of your codebase.</p>"},{"location":"index.html#restrict-conftest-imports","title":"Restrict Conftest Imports","text":"<p>In the context of pytest, <code>conftest.py</code> files are utilized to define fixtures and other setup code for tests. Importing within these files can lead to unexpected behavior, potentially affecting test outcomes.</p> <p>The <code>--restrict-conftest-imports</code> flag restricts imports within <code>conftest.py</code> files, mitigating the risk of unintended side effects. This flag is turned on by default.</p> <pre><code>[flake8]\nrestrict_conftest_imports = True\n</code></pre> <p>By restricting imports within <code>conftest.py</code>, you promote a more controlled and predictable testing environment. This aligns with best practices for test setup and minimizes potential complications.</p>"},{"location":"index.html#plugin-limitations","title":"Plugin Limitations","text":"<ul> <li> <p>This plugin is currently only compatible with Python 3.10+     (support for 3.8 and 3.9 in the works).</p> </li> <li> <p>Option custom-restrictions only supports restricting     imports by package or module, not by class or function     (i.e., <code>module_a.ClassA</code> or <code>module_a.function</code>).     However, if you are trying to set import restrictions     for a class or function, best practices would dictate     that you should move that class or function to a     separate module.</p> </li> <li> <p>Files are not supported yet, use modules to set restrictions     (e.g., <code>package/module/file.py</code> -&gt; <code>package.module.file</code>).</p> </li> <li> <p>Support for project level exceptions is not implemented yet.     (e.g., you would like to restrict aliased imports but allow     certain commonly aliased imports such as <code>numpy as np</code>).</p> </li> <li> <p>Option <code>top-level-only-imports</code> has not been implemented yet.</p> </li> <li> <p>Config checks have not been fully implemented yet, so     it's possible to have invalid configurations that will     not be caught by the plugin.     (e.g., you designated a package or module as std-lib-only and     third-party-only at the same time).</p> </li> <li> <p>Private imports in tests are not supported yet. This     means that if you have a test file that imports a private     module, it will be flagged by the plugin. (An easy fix,     including here in case I don't get to implementing it     right away). Set the <code>--restrict-private-imports</code> flag     to False in your config file if problematic.</p> </li> </ul>"},{"location":"api_docs.html","title":"API Documentation","text":""},{"location":"api_docs.html#api-documentation","title":"API Documentation","text":""},{"location":"api_docs.html#todo-add-api-documentation-here","title":"TODO. Add API documentation here.","text":""},{"location":"changelog.html","title":"Changelog","text":""},{"location":"changelog.html#v116-2025-01-14","title":"v1.1.6 (2025-01-14)","text":""},{"location":"changelog.html#fix","title":"Fix","text":"<ul> <li>deps: bump Python version (#292)</li> </ul>"},{"location":"changelog.html#v115-2025-01-09","title":"v1.1.5 (2025-01-09)","text":""},{"location":"changelog.html#fix_1","title":"Fix","text":"<ul> <li>main-app: update vulnerabilities (#285)</li> </ul>"},{"location":"changelog.html#v114-2023-11-10","title":"v1.1.4 (2023-11-10)","text":""},{"location":"changelog.html#fix_2","title":"Fix","text":"<ul> <li>parse-utils: checking custom rules against file package names instead (#225)</li> </ul>"},{"location":"changelog.html#v113-2023-08-25","title":"v1.1.3 (2023-08-25)","text":""},{"location":"changelog.html#fix_3","title":"Fix","text":"<ul> <li>file-utils: fix could not find prefix for file, adding find pref\u2026 (#191)</li> <li>file-utils: update to return the longest path in get file path f\u2026 (#190)</li> </ul>"},{"location":"changelog.html#v112-2023-08-24","title":"v1.1.2 (2023-08-24)","text":""},{"location":"changelog.html#fix_4","title":"Fix","text":"<ul> <li>readme: fix broken links (#186)</li> <li>readme: using new logo that renders, before had been using javascript which does not render on GitHub (#185)</li> <li>import-rules: disabling test violation code checks within the tests directory (#181)</li> </ul>"},{"location":"changelog.html#v111-2023-08-20","title":"v1.1.1 (2023-08-20)","text":""},{"location":"changelog.html#fix_5","title":"Fix","text":"<ul> <li>flake8-plugin: switch to using strings for boolean values, for some reason using boolean options are not working as expected (#175)</li> </ul>"},{"location":"changelog.html#refactor","title":"Refactor","text":"<ul> <li>defaults: update docstrings and tests for the defaults module (#174)</li> </ul>"},{"location":"changelog.html#v110-2023-08-20","title":"v1.1.0 (2023-08-20)","text":""},{"location":"changelog.html#feat","title":"Feat","text":"<ul> <li>rule-checker: updated docstrings (#170)</li> </ul>"},{"location":"changelog.html#v100-2023-08-19","title":"v1.0.0 (2023-08-19)","text":""},{"location":"changelog.html#feat_1","title":"Feat","text":"<ul> <li>pyproject: update development status (#167)</li> <li>pyproject: update development status (#165)</li> </ul>"},{"location":"changelog.html#v0110-2023-08-19","title":"v0.11.0 (2023-08-19)","text":""},{"location":"changelog.html#feat_2","title":"Feat","text":"<ul> <li>flake8-plugin: add check for rule conflicts (#160)</li> </ul>"},{"location":"changelog.html#v0101-2023-08-19","title":"v0.10.1 (2023-08-19)","text":""},{"location":"changelog.html#fix_6","title":"Fix","text":"<ul> <li>import-rules: update restricted packages to correctly identify the packages and modules and subpackages that need to be restricted (#137)</li> <li>import-rules: update checks for import restrictions to correctly identify restricted imports (#136)</li> <li>import-rules: corrected finding packages that match import restrictions (#135)</li> <li>checker: use import restrictions from plugin and update test files (#134)</li> <li>import-rules: update functions (#128)</li> <li>import-rules: update isolated modules to account for imports from package itself (#126)</li> </ul>"},{"location":"changelog.html#refactor_1","title":"Refactor","text":"<ul> <li>readme-and-import-rules: update flag descriptions, add documentation, and refactor code to be more pythonic and efficient (#152)</li> <li>custom-restrictions: renamed import restrictions, custom re\u2026 (#151)</li> <li>dynamic-imports: added additional dynamic import checks, updated documentation to be more thorough, and added test cases to a function that did not have any (#150)</li> <li>local-imports: Use local scope imports for clarity instead (#148)</li> <li>isolated-packages-flag: renamed isolated modules flag to standalone modules to better reflect and describe what the flag does (#146)</li> <li>restricted-import-visitor: remove check module exists option from the restricted import visitor class, not used and unnecessary (#139)</li> <li>restricted-import-visitor: remove package imports in this class, calculated elsewhere (#138)</li> <li>plugin: update plugin to use preprocessed checker settings for restricted packages and import restrictions (#133)</li> <li>restricted-import-visitor: update restricted import visitor class to include whether restriction is from a restricted package or restricted import (#132)</li> <li>error-codes: update import restriction error codes (#131)</li> <li>restricted-import-visitor: move utility functions to restricted import utils module (#130)</li> </ul>"},{"location":"changelog.html#v0100-2023-08-07","title":"v0.10.0 (2023-08-07)","text":""},{"location":"changelog.html#feat_3","title":"Feat","text":"<ul> <li>option-utils: add check conflict function and add tests (#124)</li> </ul>"},{"location":"changelog.html#fix_7","title":"Fix","text":"<ul> <li>file-utils: add try except section to find prefix function (#123)</li> </ul>"},{"location":"changelog.html#refactor_2","title":"Refactor","text":"<ul> <li>import-rules: update typing to use specific parsed node classes (#120)</li> <li>checker: remove unused functions (#116)</li> <li>docs: update documentation directory (#114)</li> </ul>"},{"location":"changelog.html#v092-2023-08-04","title":"v0.9.2 (2023-08-04)","text":""},{"location":"changelog.html#refactor_3","title":"Refactor","text":"<ul> <li>docs: update documentation directory</li> <li>readme: update readme section titles (#113)</li> </ul>"},{"location":"changelog.html#v091-2023-08-04","title":"v0.9.1 (2023-08-04)","text":""},{"location":"changelog.html#refactor_4","title":"Refactor","text":"<ul> <li>file-utils: remove unused functions (#112)</li> </ul>"},{"location":"changelog.html#v090-2023-08-03","title":"v0.9.0 (2023-08-03)","text":""},{"location":"changelog.html#fix_8","title":"Fix","text":"<ul> <li>pyproject: fix flake8 extension (#108)</li> <li>node-visitor: stdlib_list should be imported locally where it is used (#106)</li> <li>restricted-visitor: refactor get strings functions (#84)</li> <li>visitor: get_module_name_from_filename uses filename not file_path (#83)</li> <li>default: fix default settings (#77)</li> </ul>"},{"location":"changelog.html#refactor_5","title":"Refactor","text":"<ul> <li>node-utils: remove unused function (#111)</li> <li>pyproject: add project info (#109)</li> <li>dependencies: remove pandas and numpy dependencies (#96)</li> <li>example_repos: remove pendulum dependency (#95)</li> <li>readme: update intro paragraph, remove unnecessary comments (#88)</li> <li>error-codes: make error code checks using set instead of list (#86)</li> <li>core: refactor to make code easier to follow (#85)</li> <li>help-strings: add error codes to flake8 help strings (#82)</li> <li>defaults: update help strings (#81)</li> <li>main: update readme, change log to debug (#80)</li> <li>restricted-imports: add support for import restrictions (#79)</li> <li>defaults: update converters and add test cases (#78)</li> <li>import-rules: update import rules to implement restricted i\u2026 (#76)</li> </ul>"},{"location":"changelog.html#v0810-2023-08-02","title":"v0.8.10 (2023-08-02)","text":""},{"location":"changelog.html#refactor_6","title":"Refactor","text":"<ul> <li>node-utils: remove unused function (#111)</li> </ul>"},{"location":"changelog.html#v089-2023-08-01","title":"v0.8.9 (2023-08-01)","text":""},{"location":"changelog.html#fix_9","title":"Fix","text":"<ul> <li>pyproject: fix flake8 extension (#108)</li> <li>node-visitor: stdlib list should be imported locally where it is used (#106)</li> </ul>"},{"location":"changelog.html#refactor_7","title":"Refactor","text":"<ul> <li>pyproject: add project info (#109)</li> </ul>"},{"location":"changelog.html#v088-2023-07-31","title":"v0.8.8 (2023-07-31)","text":""},{"location":"changelog.html#refactor_8","title":"Refactor","text":"<ul> <li>dependencies: remove pandas and numpy dependencies (#96)</li> </ul>"},{"location":"changelog.html#v087-2023-07-31","title":"v0.8.7 (2023-07-31)","text":""},{"location":"changelog.html#refactor_9","title":"Refactor","text":"<ul> <li>example_repos: remove pendulum dependency (#95)</li> </ul>"},{"location":"changelog.html#v086-2023-07-31","title":"v0.8.6 (2023-07-31)","text":""},{"location":"changelog.html#refactor_10","title":"Refactor","text":"<ul> <li>readme: update intro paragraph, remove unnecessary comments (#88)</li> <li>error-codes: make error code checks using set instead of list (#86)</li> <li>core: refactor to make code easier to follow (#85)</li> </ul>"},{"location":"changelog.html#v085-2023-07-31","title":"v0.8.5 (2023-07-31)","text":""},{"location":"changelog.html#fix_10","title":"Fix","text":"<ul> <li>restricted-visitor: refactor get strings functions (#84)</li> </ul>"},{"location":"changelog.html#refactor_11","title":"Refactor","text":"<ul> <li>core: refactor to make code easier to follow (#85)</li> </ul>"},{"location":"changelog.html#v084-2023-07-31","title":"v0.8.4 (2023-07-31)","text":""},{"location":"changelog.html#fix_11","title":"Fix","text":"<ul> <li>visitor: get_module_name_from_filename uses filename not file_path (#83)</li> </ul>"},{"location":"changelog.html#refactor_12","title":"Refactor","text":"<ul> <li>help-strings: add error codes to flake8 help strings (#82)</li> </ul>"},{"location":"changelog.html#v083-2023-07-31","title":"v0.8.3 (2023-07-31)","text":""},{"location":"changelog.html#refactor_13","title":"Refactor","text":"<ul> <li>defaults: update help strings (#81)</li> <li>main: update readme, change log to debug (#80)</li> <li>restricted-imports: add support for import restrictions (#79)</li> </ul>"},{"location":"changelog.html#v082-2023-07-30","title":"v0.8.2 (2023-07-30)","text":""},{"location":"changelog.html#fix_12","title":"Fix","text":"<ul> <li>default: fix default settings (#77)</li> </ul>"},{"location":"changelog.html#refactor_14","title":"Refactor","text":"<ul> <li>defaults: update converters and add test cases (#78)</li> <li>import-rules: update import rules to implement restricted i\u2026 (#76)</li> </ul>"},{"location":"changelog.html#v081-2023-07-28","title":"v0.8.1 (2023-07-28)","text":""},{"location":"changelog.html#refactor_15","title":"Refactor","text":"<ul> <li>restricted-imports: passing file packages to restricted imp\u2026 (#75)</li> </ul>"},{"location":"changelog.html#v080-2023-07-28","title":"v0.8.0 (2023-07-28)","text":""},{"location":"changelog.html#feat_4","title":"Feat","text":"<ul> <li>checker: added support for restricted imports (#69)</li> <li>restricted-imports: added restricted import visitor and utility functions (#68)</li> </ul>"},{"location":"changelog.html#fix_13","title":"Fix","text":"<ul> <li>rules-checker: fix typing in restricted identifiers (#72)</li> <li>file-utils: return none if file does not exist (#71)</li> <li>add parsing for import restrictions (#67)</li> </ul>"},{"location":"changelog.html#refactor_16","title":"Refactor","text":"<ul> <li>rules-checker: remove extraneous code to make more efficient (#74)</li> <li>rules-checker: refactoring to minimize the number of calls (#73)</li> <li>file-utils: move file util functions to own module (#70)</li> <li>update parsing tests and plugin (#66)</li> <li>import-rules: update custom import rules to use closure (#65)</li> <li>cleaned up functions and improved method names (#64)</li> </ul>"},{"location":"changelog.html#v071-2023-07-25","title":"v0.7.1 (2023-07-25)","text":""},{"location":"changelog.html#refactor_17","title":"Refactor","text":"<ul> <li>cleaned up functions and improved method names</li> </ul>"},{"location":"changelog.html#v070-2023-07-25","title":"v0.7.0 (2023-07-25)","text":""},{"location":"changelog.html#feat_5","title":"Feat","text":"<ul> <li>standalone-modules: add test cases (#62)</li> <li>parse-utils: add module to filename helpers (#61)</li> <li>project-imports: added support for non-base and non-first party (#60)</li> <li>first-party: updated first party to include base package (#59)</li> <li>future: add support for restricting future imports (#58)</li> <li>error-codes: updated error code messages (#57)</li> <li>third-party: added support for third party only imports (#56)</li> <li>imports: update imports to straight imports (#55)</li> <li>import-rules: implement std lib import restrictions (#54)</li> <li>parse-utils: add file conversion utils (#53)</li> <li>checker: update checkers and parsers (#52)</li> <li>registry: remove old registry options (#50)</li> <li>flake8-linter: add register options (#49)</li> <li>dynamic: add custom import rules to default settings (#48)</li> <li>import-rules: add handling for dynamic string syntax errors (#47)</li> <li>added support for standard lib packages (#45)</li> <li>dynamic: added dynamic string visitor to capture dynamic string\u2026 (#44)</li> </ul>"},{"location":"changelog.html#refactor_18","title":"Refactor","text":"<ul> <li>update support for #noqa (#51)</li> <li>error-codes: update error code messages (#46)</li> </ul>"},{"location":"changelog.html#v060-2023-07-22","title":"v0.6.0 (2023-07-22)","text":""},{"location":"changelog.html#feat_6","title":"Feat","text":"<ul> <li>dynamic: added support for dynamic imports and fixed numerous tests (#42)</li> </ul>"},{"location":"changelog.html#refactor_19","title":"Refactor","text":"<ul> <li>nodes: moved parsed nodes to their own file (#43)</li> </ul>"},{"location":"changelog.html#v050-2023-07-21","title":"v0.5.0 (2023-07-21)","text":""},{"location":"changelog.html#refactor_20","title":"Refactor","text":"<ul> <li>import-rules: add restrictions for main imports (#39)</li> <li>import-rules: add private import restrictions (#38)</li> </ul>"},{"location":"changelog.html#v045-2023-07-20","title":"v0.4.5 (2023-07-20)","text":""},{"location":"changelog.html#refactor_21","title":"Refactor","text":"<ul> <li>import-rules: implement local import restrictions (#37)</li> <li>import-rules: add aliased import restrictions (#36)</li> <li>import-rules: add conditional import restrictions (#35)</li> </ul>"},{"location":"changelog.html#v044-2023-07-20","title":"v0.4.4 (2023-07-20)","text":""},{"location":"changelog.html#refactor_22","title":"Refactor","text":"<ul> <li>import-rules: add relative import restrictions (#34)</li> <li>test-cases: updated wildcard import checks (#33)</li> </ul>"},{"location":"changelog.html#v043-2023-07-20","title":"v0.4.3 (2023-07-20)","text":""},{"location":"changelog.html#refactor_23","title":"Refactor","text":"<ul> <li>tests: update tests to use linter fixture (#32)</li> <li>implement and connect import rules (#31)</li> <li>import-rules: remove option arguments, use option dict directly (#30)</li> <li>update setting option keys (#29)</li> <li>update linters and vistor and error codes (#28)</li> <li>error-codes: add properties for code and message (#27)</li> </ul>"},{"location":"changelog.html#v042-2023-07-19","title":"v0.4.2 (2023-07-19)","text":""},{"location":"changelog.html#refactor_24","title":"Refactor","text":"<ul> <li>updated linter, checker, and visitor classes and tests (#26)</li> </ul>"},{"location":"changelog.html#v041-2023-07-19","title":"v0.4.1 (2023-07-19)","text":""},{"location":"changelog.html#refactor_25","title":"Refactor","text":"<ul> <li>error-codes: update error code stem (#25)</li> </ul>"},{"location":"changelog.html#v040-2023-07-19","title":"v0.4.0 (2023-07-19)","text":""},{"location":"changelog.html#feat_7","title":"Feat","text":"<ul> <li>main-package: updated node visitor and added tests (#22)</li> </ul>"},{"location":"changelog.html#refactor_26","title":"Refactor","text":"<ul> <li>checker: use attrs define and field with slots (#24)</li> </ul>"},{"location":"changelog.html#v030-2023-07-17","title":"v0.3.0 (2023-07-17)","text":""},{"location":"changelog.html#feat_8","title":"Feat","text":"<ul> <li>makefile: Added linter files (#15)</li> <li>error-codes: defined error codes for what linter will cover (#10)</li> </ul>"},{"location":"changelog.html#fix_14","title":"Fix","text":"<ul> <li>error-codes: added methods to error codes enum (#12)</li> </ul>"},{"location":"changelog.html#refactor_27","title":"Refactor","text":"<ul> <li>import-rules: move files into directories (#21)</li> <li>main-package: continuing to implement checker (#20)</li> <li>example-package: updating imports and docstrings (#19)</li> <li>example-package: rename package and updating imports (#18)</li> <li>custom-import-rules: update parameters (#17)</li> <li>visitor: Consolidate visitor classes (#16)</li> </ul>"},{"location":"changelog.html#v020-2023-04-27","title":"v0.2.0 (2023-04-27)","text":""},{"location":"changelog.html#feat_9","title":"Feat","text":"<ul> <li>added import rules module and parse utils and error codes (#9)</li> <li>added rules checker class to process the results of parsing through file (#8)</li> <li>add custom import rules visitor class for traversing imports (#6)</li> </ul>"},{"location":"changelog.html#v010-2023-04-26","title":"v0.1.0 (2023-04-26)","text":""},{"location":"changelog.html#feat_10","title":"Feat","text":"<ul> <li>added parsed import namedtuple for holding parsed imports from ast</li> </ul>"},{"location":"changelog.html#v001-2023-04-24","title":"v0.0.1 (2023-04-24)","text":""},{"location":"changelog.html#feat_11","title":"Feat","text":"<ul> <li>add Visitor and Plugin classes</li> </ul>"},{"location":"dynamic_imports.html","title":"Dynamic Imports Explained","text":""},{"location":"dynamic_imports.html#dynamic-imports-explained","title":"Dynamic Imports Explained","text":"<p>Dynamic imports, also known as lazy loading, refer to the practice of importing modules or specific symbols from modules at runtime, rather than at the beginning of the program's execution. This allows for more flexible and optimized code by loading resources only when they are needed.</p>"},{"location":"dynamic_imports.html#why-we-dont-want-dynamic-imports","title":"Why We Don't Want Dynamic Imports","text":"<p>While dynamic importing is a powerful feature that allows modules to be loaded when needed or at runtime, there are several reasons why it might not always be a preferred approach:</p> <ol> <li> <p>Code Readability: Dynamic imports can make code more complex and harder to understand. This complexity can lead to difficulties in maintaining and debugging the code, especially for those who are not familiar with the specific use of dynamic imports.</p> </li> <li> <p>Security Risks: Using functions like <code>exec()</code> for dynamic imports can pose significant security risks, especially when dealing with untrusted input. Malicious code can be executed unintentionally, leading to potential breaches and vulnerabilities.</p> </li> <li> <p>Performance Considerations: Dynamic imports can introduce overhead at runtime, potentially leading to performance issues. Loading modules dynamically can slow down the execution, especially if done excessively or improperly.</p> </li> <li> <p>Dependency Tracking: Dynamic imports can make it challenging to track dependencies and manage them properly. Tools that analyze code dependencies might not detect dynamically imported modules, leading to problems in dependency management and potential conflicts.</p> </li> <li> <p>Testing Challenges: Writing tests for code that utilizes dynamic imports can be more complex. Ensuring proper coverage and creating mock objects for testing might become cumbersome and error-prone.</p> </li> <li> <p>Lack of Community Standards: Dynamic imports are not commonly used in many coding communities, and there might not be established best practices or conventions. This lack of standardization can lead to inconsistency and confusion across different parts of the codebase.</p> </li> <li> <p>Potential Compatibility Issues: Some methods of dynamic importing might not be compatible across different versions of Python or with certain third-party libraries and tools. This can lead to unexpected behaviors and require additional effort to ensure compatibility.</p> </li> <li> <p>Loss of IDE Support: Many Integrated Development Environments (IDEs) provide features like auto-completion, refactoring, and navigation based on static analysis of imports. Dynamic imports can break these features, reducing development efficiency and productivity.</p> </li> </ol> <p>In summary, while dynamic imports offer flexibility and can be useful in specific scenarios, they come with trade-offs that must be carefully considered. The potential complexity, security risks, and other challenges mean that dynamic imports should be used judiciously, following best practices, and with a clear understanding of the implications.</p> <p>NOTE: If dynamic imports are essential for a particular use case, it is recommended to follow established guidelines and best practices, utilize trusted libraries, and thoroughly test the implementation to mitigate the associated risks and challenges.</p> <p>Dynamic importing is a method where modules are loaded when they are needed, or at runtime. Python provides several built-in functions and packages that support dynamic imports. Here are a few examples:</p>"},{"location":"dynamic_imports.html#examples-from-built-in-functions","title":"Examples From Built-In Functions","text":"<p>Python provides several built-in functions and packages that support dynamic imports. Here are a few examples:</p>"},{"location":"dynamic_imports.html#1-importlib","title":"1. <code>importlib</code>","text":"<p>This is a built-in Python library that offers functions for importing modules programmatically. The <code>import_module()</code> function is commonly used for dynamic imports. Here\u2019s an example:</p> <pre><code>\"\"\"Dynamic Imports importlib Example\"\"\"\nimport importlib\n\nmodule = importlib.import_module('math')\nprint(module.sqrt(4))  # Outputs: 2.0\n</code></pre>"},{"location":"dynamic_imports.html#2-__import__","title":"2. <code>__import__()</code>","text":"<p>This is a built-in Python function that can be used for dynamic imports. However, it\u2019s generally recommended to use <code>importlib.import_module()</code> instead, as <code>__import__()</code> is more complex and not intended for direct use. Here\u2019s an example:</p> <pre><code>\"\"\"Dynamic Imports importlib Example\"\"\"\nmodule_name = \"math\"\nmodule = __import__(module_name)\nprint(module.sqrt(4))\n# Outputs: 2.0\n</code></pre>"},{"location":"dynamic_imports.html#3-exec-and-eval","title":"3. <code>exec() and eval()</code>","text":"<p>This is a built-in Python function that can execute Python code dynamically. It can be used for dynamic imports, but it\u2019s generally not recommended because it can pose security risks if used with untrusted input. Here\u2019s an example:</p> <pre><code>\"\"\"Dynamic Imports Execute Example\"\"\"\nmodule_name = \"math\"\nexec(f\"import {module_name}\")\nprint(math.sqrt(4))\n# Outputs: 2.0\n</code></pre>"},{"location":"dynamic_imports.html#4-globals-and-locals","title":"4. <code>globals()</code> and <code>locals()</code>","text":"<p>These are built-in Python functions that return the current global and local symbol table, respectively. They can be used in conjunction with <code>exec()</code> or <code>__import__()</code> to dynamically import modules into the current namespace.</p> <p>Here\u2019s an example of using <code>globals()</code> with <code>__import__()</code> to dynamically import a module into the current namespace:</p> <pre><code>\"\"\"Dynamic Imports Globals Example\"\"\"\nmodule_name = \"math\"\nglobals()[module_name] = __import__(\"math\")\n\n# Now you can use the 'math' module directly\nprint(math.sqrt(4))\n# Outputs: 2.0\n</code></pre> <p>And here\u2019s an example of using <code>locals()</code> with <code>exec()</code> to dynamically import a module into the current namespace:</p> <pre><code>\"\"\"Dynamic Imports Example\"\"\"\nmodule_name = \"math\"\nexec(f\"{module_name} = __import__('{module_name}')\")\n\n# Now you can use the 'math' module directly\nprint(math.sqrt(4))\n# Outputs: 2.0\n</code></pre> <p>In this example, <code>exec(f\"{module_name} = __import__('{module_name}')\")</code> executes a string of Python code that imports the <code>math</code> module and adds it to the local symbol table. This allows you to use the <code>math</code> module directly in your code, just like if you had imported it with <code>import math</code>.</p> <p>The <code>exec()</code> function should be used with caution, as it can pose security risks if used with untrusted input.</p>"},{"location":"dynamic_imports.html#5-pkgutil","title":"5. <code>pkgutil</code>","text":"<p>This is a standard library in Python that supports the discovery and loading of Python packages and modules. It can be used to dynamically load modules. Here's an example:</p> <pre><code>\"\"\"Dynamic Imports pkgutil Example\"\"\"\nimport pkgutil\n\n# Load the 'os' module\nmodule = pkgutil.get_loader('os').load_module('os')\n</code></pre>"},{"location":"dynamic_imports.html#6-pkgutilget_loader","title":"6. <code>pkgutil.get_loader</code>","text":"<p>This function within the <code>pkgutil</code> library returns a PEP 302 \"loader\" object for a module. It can be used to dynamically load the specified module. Here's an example:</p> <pre><code>\"\"\"Dynamic Imports pkgutil.get_loader Example\"\"\"\nfrom pkgutil import get_loader\n\n# Load the 'os' module\nmodule = get_loader('os').load_module('os')\n</code></pre>"},{"location":"dynamic_imports.html#7-pkgutiliter_modules","title":"7. <code>pkgutil.iter_modules</code>","text":"<p>This function in the <code>pkgutil</code> module is used to iterate over all the modules in a given package. It's useful for discovering modules dynamically. Here's an example:</p> <pre><code>\"\"\"Dynamic Imports pkgutil.iter_modules Example\"\"\"\nimport pkgutil\n\n# List all the modules in the 'os' package\nfor module_info in pkgutil.iter_modules(['os']):\n    print(module_info)\n</code></pre>"},{"location":"dynamic_imports.html#8-zipimport","title":"8. <code>zipimport</code>","text":"<p>This is a built-in Python module that allows the importing of Python modules from zip archives. It can be used to dynamically import modules stored in zip files. Here's an example:</p> <pre><code>\"\"\"Dynamic Imports zipimport Example\"\"\"\nimport zipimport\n\n# Import a module from a zip archive\nzipimporter = zipimport.zipimporter('my_module.zip')\nmodule = zipimporter.load_module('my_module')\n</code></pre>"},{"location":"dynamic_imports.html#9-zipimportzipimporter","title":"9. <code>zipimport.zipimporter</code>","text":"<p>This class within the <code>zipimport</code> module provides access to resources within a zip archive. It allows for dynamic importing of modules from zip archives. Here's an example:</p> <pre><code>\"\"\"Dynamic Imports zipimport.zipimporter Example\"\"\"\nfrom zipimport import zipimporter\n\n# Import a module from a zip archive\nzipimporter = zipimporter('my_module.zip')\nmodule = zipimporter.load_module('my_module')\n</code></pre> <p>NOTE: Remember, dynamic imports can make code harder to understand and debug, and they can pose security risks if used improperly. Therefore, they should be used sparingly and with caution.</p> <p>These improvements make sure that the latter sections align with the formatting and explanation style of the previous sections, providing a consistent reading experience throughout the document.</p>"},{"location":"glossary.html","title":"Glossary","text":""},{"location":"glossary.html#glossary-and-terminology","title":"Glossary and Terminology","text":"<p>Welcome to the \"Glossary,\" a comprehensive guide to understanding key concepts and terminology in the <code>flake8-custom-import-rules</code> package.</p>"},{"location":"glossary.html#important-terms-used-in-this-package","title":"Important Terms Used in This Package","text":"<ul> <li>Aliased Imports</li> <li>Conditional Imports</li> <li>Dynamic Imports</li> <li>Future Imports (__future__)</li> <li>Importing a Package Locally</li> <li>Local Scope Import</li> <li>Main Script Imports (__main__)</li> <li>Private Imports</li> <li>Python Modules</li> <li>Python Packages</li> <li>Relative Imports</li> <li>Root Package</li> <li>Wildcard Imports</li> </ul>"},{"location":"glossary.html#aliased-imports","title":"Aliased Imports","text":"<p>Aliased imports in Python refer to the practice of importing a module or specific symbols from a module under a different name, typically to make the code more concise or to avoid naming conflicts. This is done using the <code>as</code> keyword, allowing you to assign a different name (alias) to the imported module or symbol.</p> <p>Here's an example of an aliased import:</p> <pre><code>import numpy as np\n</code></pre> <p>In this example, the numpy module is imported under the alias np, so you can refer to it as np in your code instead of numpy. This is a common convention in the scientific and data analysis community.</p> <p>Here's another example, where a specific symbol is aliased:</p> <pre><code>from matplotlib import pyplot as plt\n</code></pre> <p>Here, the <code>pyplot</code> module from the <code>matplotlib</code> package is imported under the alias <code>plt</code>.</p>"},{"location":"glossary.html#advantages-of-aliased-imports","title":"Advantages of Aliased Imports:","text":"<ol> <li> <p>Conciseness: Aliasing can make the code more     concise, especially when dealing with modules or     symbols with long or cumbersome names.</p> </li> <li> <p>Avoiding Naming Conflicts: If you have symbols     with the same name in different modules, you can use     aliasing to avoid conflicts.</p> </li> <li> <p>Community Conventions: Certain aliases are widely     recognized and used in specific communities, such as     <code>np</code> for <code>numpy</code> or <code>pd</code> for <code>pandas</code>.</p> </li> </ol>"},{"location":"glossary.html#disadvantages-and-considerations","title":"Disadvantages and Considerations:","text":"<ol> <li>Potential Confusion: Non-standard or     unconventional aliases might lead to confusion,     especially for readers who are not familiar with the     specific aliasing choices.</li> <li>Loss of Clarity: Overuse of aliasing or using     overly short or cryptic aliases can reduce the     readability of the code.</li> </ol>"},{"location":"glossary.html#best-practices-and-recommendations","title":"Best Practices and Recommendations:","text":"<ul> <li>Use Standard Aliases: Where possible, stick to     widely recognized and accepted aliases, such as <code>np</code>     for <code>numpy</code>.</li> <li>Be Clear and Consistent: If you choose to use     aliases, make sure they are clear, descriptive, and     used consistently throughout your codebase.</li> <li>Consider Readability: Use aliasing judiciously and     consider the trade-off between conciseness and     readability.</li> </ul> <p>In summary, aliased imports are a useful tool in Python, allowing for more concise code and the ability to handle naming conflicts. However, they should be used thoughtfully and in line with community standards and best practices to maintain code clarity and readability.</p>"},{"location":"glossary.html#conditional-imports","title":"Conditional Imports","text":"<p>Conditional imports in Python refer to the practice of importing a module or specific symbols from a module based on certain conditions or runtime logic. This means that the import statement is executed only if a particular condition is met, typically determined by an <code>if</code> statement or similar control structure.</p> <p>Here's an example that illustrates the concept of conditional imports:</p> <pre><code>import sys\n\nif sys.version_info[0] == 3:\n    import urllib.request as urllib_request\nelse:\n    import urllib2 as urllib_request\n</code></pre> <p>In this example, the code checks the major version of Python being used and imports the appropriate module accordingly. This can be useful for maintaining compatibility across different versions of Python or other varying environments.</p>"},{"location":"glossary.html#advantages-of-conditional-imports","title":"Advantages of Conditional Imports:","text":"<ol> <li> <p>Compatibility: As shown above, conditional     imports can be used to handle differences between     Python versions, platforms, or other varying     environments, helping to maintain compatibility.</p> </li> <li> <p>Optimization: By importing modules only when     necessary, you might optimize the loading time or     resource utilization of your program, especially when     dealing with large or resource-heavy modules.</p> </li> </ol>"},{"location":"glossary.html#disadvantages-and-risks-of-conditional-imports","title":"Disadvantages and Risks of Conditional Imports:","text":"<ol> <li> <p>Code Complexity: Conditional imports can increase     the complexity of the code, making it harder to read,     understand, and maintain.</p> </li> <li> <p>Potential Inconsistency: The behavior of the code     might become inconsistent or harder to predict, as the     availability of a module or specific symbols may     depend on runtime conditions.</p> </li> </ol>"},{"location":"glossary.html#best-practices-and-recommendations_1","title":"Best Practices and Recommendations:","text":"<ul> <li>Clear Documentation: If you use conditional     imports, make sure to document the conditions and the     reasoning behind them to help others (and yourself)     understand the code.</li> <li>Testing: Thoroughly test the code under different     conditions to ensure that the conditional imports work     as intended and do not introduce unexpected behavior or     bugs.</li> <li>Avoid Overuse: Consider whether conditional     imports are truly necessary for your use case, and     avoid overusing them, as they can lead to more complex     and challenging-to-maintain code.</li> </ul> <p>Conditional imports are a tool best suited for specific scenarios, such as handling differences between Python versions or platforms. In general code, it's usually preferable to stick with straightforward and consistent import statements.</p>"},{"location":"glossary.html#dynamic-imports","title":"Dynamic Imports","text":"<p>Dynamic imports in Python refer to the practice of importing modules or specific symbols from modules at runtime, based on conditions or logic within the code. Unlike standard imports, which are resolved at the time the code is compiled, dynamic imports are resolved when the code is executed. This is achieved using functions like <code>importlib.import_module</code> or the built-in <code>__import__</code> function.</p> <p>Here's an example that illustrates the concept of dynamic imports:</p> <pre><code>import importlib\n\nmodule_name = \"os\" if some_condition else \"sys\"\nmodule = importlib.import_module(module_name)\n</code></pre> <p>In this example, the code dynamically imports either the <code>os</code> or <code>sys</code> module, depending on the value of <code>some_condition</code>.</p>"},{"location":"glossary.html#advantages-of-dynamic-imports","title":"Advantages of Dynamic Imports:","text":"<ol> <li> <p>Flexibility: Dynamic imports allow you to load modules     based on runtime conditions, giving you more control and     adaptability in your code.</p> </li> <li> <p>Optimization: By importing modules only when needed, you     can potentially reduce the initial loading time or resource     utilization of your application.</p> </li> </ol>"},{"location":"glossary.html#disadvantages-and-risks-of-dynamic-imports","title":"Disadvantages and Risks of Dynamic Imports:","text":"<ol> <li> <p>Code Complexity: Dynamic imports can add complexity to     the code, making it more challenging to read, understand, and     maintain.</p> </li> <li> <p>Potential Errors: Errors related to dynamic imports might     only manifest at runtime, making them harder to catch and     debug.</p> </li> </ol>"},{"location":"glossary.html#best-practices-and-recommendations_2","title":"Best Practices and Recommendations:","text":"<ul> <li> <p>Use Standard Libraries: Utilize the <code>importlib</code> standard     library for dynamic imports rather than relying on the     lower-level <code>__import__</code> function.</p> </li> <li> <p>Testing: Ensure thorough testing of the code paths that     involve dynamic imports to catch potential issues.</p> </li> <li> <p>Documentation: Clearly document the reasoning and usage of     dynamic imports in the code to aid understanding.</p> </li> </ul>"},{"location":"glossary.html#limitations-and-considerations","title":"Limitations and Considerations:","text":"<ul> <li>Static Analysis Limitations: Tools that perform static     analysis on the code might have difficulty handling dynamic     imports, as the imported modules are determined at runtime.</li> </ul> <p>In summary, dynamic imports are a powerful but complex feature in Python, allowing for more adaptable and potentially optimized code. Care must be taken in their use to ensure clarity, maintainability, and robustness.</p>"},{"location":"glossary.html#future-imports-__future__","title":"Future Imports ( __future__ )","text":"<p>Future imports in Python are a special mechanism that allows you to enable features that will become standard in future versions of the language. By using future imports, you can ensure compatibility with newer Python versions and make your code more forward-compatible.</p> <p>The <code>__future__</code> module in Python provides these future import statements. When you import a feature from <code>__future__</code>, it changes the compiler's behavior to include that feature, even if it's not the default behavior in the current version of Python.</p> <p>Here's an example of a future import:</p> <pre><code>from __future__ import division\n</code></pre> <p>This import changes the division operator <code>/</code> to always perform true division, returning a floating-point result even when dividing two integers. This behavior became the default in Python 3, but the above import allows you to use it in Python 2 as well.</p>"},{"location":"glossary.html#common-uses-of-future-imports","title":"Common Uses of Future Imports:**","text":"<ol> <li> <p>Division Behavior: As shown above, changing the     behavior of the division operator to be consistent     with Python 3.</p> </li> <li> <p>Print Function: Enabling the use of the <code>print</code>     function instead of the <code>print</code> statement in Python 2,     making the code compatible with Python 3.</p> </li> <li> <p>Unicode Literals: Enabling the use of Unicode     literals in Python 2, consistent with the behavior in     Python 3.</p> </li> </ol>"},{"location":"glossary.html#advantages-of-future-imports","title":"Advantages of Future Imports:","text":"<ol> <li> <p>Forward Compatibility: Future imports help prepare     your code for future versions of Python, making the     transition smoother when you decide to upgrade.</p> </li> <li> <p>Consistency: If you're working in an environment     with different versions of Python, future imports can     help ensure consistent behavior across those versions.</p> </li> </ol>"},{"location":"glossary.html#considerations-and-best-practices","title":"Considerations and Best Practices:","text":"<ol> <li> <p>Explicitness: Future imports should be used     explicitly in each module where the future behavior is     needed.</p> </li> <li> <p>Placement: Future imports must appear at the top     of the file, before any other imports or code, to affect     the entire module.</p> </li> <li> <p>Documentation: If you're using future imports, it     may be helpful to document why, especially if the reason     might not be immediately obvious to others reading the     code.</p> </li> </ol> <p>In summary, future imports are a valuable tool for ensuring forward compatibility and consistency across different Python versions. By understanding and using them appropriately, you can write code that's more robust and maintainable as the Python language evolves.</p>"},{"location":"glossary.html#importing-a-package-locally","title":"Importing a Package Locally","text":"<p>This typically refers to importing a package that resides within the local file system or project directory. It may be a package or module developed specifically for the project or a third-party package that has been downloaded and stored locally. It's accessed directly from the local path rather than from a globally installed location or package repository.</p> <p>Example:</p> <pre><code>import my_local_package\nfrom .local_module import local_function\n</code></pre> <p>In this context, \"local\" refers to the physical location of the package on the system.</p> <p>While the terms local scope import and import a package locally may sound similar, they refer to different aspects of the import process. The first is concerned with where the package or module is located on the file system, while the second deals with where in the code the import statement is placed and the scope of the imported elements.</p>"},{"location":"glossary.html#local-scope-import","title":"Local Scope Import","text":"<p>A local import often refers to an import statement that is specific to a particular scope within the code. It may mean importing a module or function within a specific function or method, rather than at the top level of a file. This type of import is often used to minimize the scope of the imported element, ensuring that it's only available where it's needed.</p> <p>Example:</p> <pre><code>def my_function():\n    \"\"\"A function that imports a module locally.\"\"\"\n    import requests  # third-party local import\n    response = requests.get('https://example.com')\n    return response.text\n</code></pre> <p>Here, \"local\" refers to the scope and context of the import, not the physical location of the imported module.</p>"},{"location":"glossary.html#advantages-of-local-scope-imports","title":"Advantages of Local Scope Imports:**","text":"<ol> <li> <p>Reduced Initial Loading Time: If a module is     imported inside a function and that function is never     called, the module won't be imported, potentially     reducing the initial loading time of the script.</p> </li> <li> <p>Avoiding Circular Dependencies: Sometimes, local     imports can help in avoiding circular dependencies     between different modules.</p> </li> <li> <p>Selective Importing: Importing only in the scope    where it is needed can help in keeping the global    namespace clean.</p> </li> </ol>"},{"location":"glossary.html#disadvantages-of-local-scope-imports","title":"Disadvantages of Local Scope Imports:**","text":"<ol> <li> <p>Potential Performance Overhead: If a function with a     local import is called many times, the import statement     will be executed each time the function is called,     which might introduce a small performance overhead.</p> </li> <li> <p>Code Clarity: Local imports can make the code harder     to follow, especially if overused, as it may become     unclear where exactly different modules and functions     are being imported.</p> </li> </ol>"},{"location":"glossary.html#when-to-use-local-scope-imports","title":"When to Use Local Scope Imports:**","text":"<p>Local scope imports are not common in every project, and their usage often depends on specific needs, coding guidelines, and design considerations. They might be used to solve particular problems like circular dependencies or to optimize the loading of large and infrequently used modules.</p> <p>Typically, code style guides recommend importing at the top level of the file for clarity and consistency, but local scope imports can be a valuable tool in certain situations.</p>"},{"location":"glossary.html#main-script-imports-__main__","title":"Main Script Imports (__main__)","text":"<p>Importing from the <code>__main__</code> module or a <code>__main__.py</code> file is generally not considered best practice in Python development.</p>"},{"location":"glossary.html#importing-from-the-__main__-module","title":"Importing from the <code>__main__</code> Module","text":"<p>The <code>__main__</code> module is the entry point of a program, and it's the context in which the top-level script is run. Importing from this module is relatively uncommon and can lead to code that is difficult to understand or maintain. Here are some reasons why:</p> <ul> <li> <p>Uncommon Practice: The <code>__main__</code> module is     typically associated with script execution, not with     defining reusable components.</p> </li> <li> <p>Potential Confusion: It might be unclear what is     being imported from <code>__main__</code>, especially if the main     script is large or complex.</p> </li> <li> <p>Code Organization Issues: Needing to import from     <code>__main__</code> may indicate that the code could benefit     from reorganization.</p> </li> <li> <p>Testing Challenges: Code that relies on imports     from <code>__main__</code> may be more difficult to test in     isolation.</p> </li> </ul>"},{"location":"glossary.html#importing-from-a-__main__py-file","title":"Importing from a <code>__main__.py</code> File","text":"<p>The <code>__main__.py</code> file is used to define the entry point for a package when it's executed as a script. Here's why importing from <code>__main__.py</code> can be problematic:</p> <ul> <li> <p>Lack of Clarity: Like the <code>__main__</code> module,     <code>__main__.py</code> is usually associated with script     execution, not with defining reusable components.</p> </li> <li> <p>Potential Circular Dependencies: You can easily end     up with circular dependencies that are difficult to     resolve.</p> </li> <li> <p>Maintenance Challenges: Serving dual purposes can     become a maintenance burden.</p> </li> <li> <p>Incompatibility with Certain Tools: Some tools     might treat <code>__main__.py</code> specially, leading to     unexpected behavior.</p> </li> </ul>"},{"location":"glossary.html#recommended-structure","title":"Recommended Structure","text":"<p>Instead of putting reusable code in the <code>__main__</code> module or <code>__main__.py</code> file, it's generally a better practice to define functions, classes, and other reusable components in separate modules within your package. Here's an example structure:</p> <pre><code>mypackage/\n\u251c\u2500\u2500 __main__.py         # Entry point for script execution\n\u251c\u2500\u2500 utilities.py        # Reusable functions and classes\n\u2514\u2500\u2500 other_module.py     # Other reusable components\n</code></pre> <p>In <code>__main__.py</code>, you can import from <code>utilities.py</code> and other_module.py as needed for script execution. This keeps your codebase organized and clear and avoids the potential problems mentioned above.</p> <p>In summary, while importing from the <code>__main__</code> module or a <code>__main__.py</code> file is technically possible, it's generally not a common or recommended practice. Organizing code into separate modules enhances clarity, maintainability, and avoids potential issues.</p>"},{"location":"glossary.html#private-imports","title":"Private Imports","text":"<p>Private imports in Python refer to the practice of importing symbols (such as functions, classes, or variables) that are intended for internal use within a module or package and are not part of the public API. These symbols are often prefixed with an underscore (<code>_</code>), which by convention signals that they are considered \"private\" or \"internal\" and should not be accessed directly by external code.</p> <p>Here's an example to illustrate private imports:</p> <p>Suppose you have a module <code>my_module.py</code>:</p> <pre><code># my_module.py\n\ndef public_function():\n    \"\"\"A public function that can be accessed externally.\"\"\"\n    return _private_helper_function()\n\ndef _private_helper_function():\n    return \"This is a private function!\"\n</code></pre> <p>You might import and use the <code>_private_helper_function</code> within the same package, but it is not intended to be accessed directly by external code.</p>"},{"location":"glossary.html#why-use-private-imports","title":"Why Use Private Imports?","text":"<ol> <li> <p>Encapsulation: By marking certain symbols as private,     you can define a clear and stable public API while keeping     the flexibility to change, remove, or refactor the internal     implementation without affecting external code.</p> </li> <li> <p>Code Organization: Private imports help organize code by     clearly separating the public interface from the internal     implementation details.</p> </li> </ol>"},{"location":"glossary.html#best-practices-and-recommendations_3","title":"Best Practices and Recommendations:","text":"<ul> <li> <p>Naming Convention: Use a single leading underscore to     mark symbols as private. This does not prevent access to the     symbols but serves as a gentle warning to other developers     that the symbol is considered internal.</p> </li> <li> <p>Documentation: Clearly document which parts of your module     or package are considered public and which are private.</p> </li> <li> <p>Respect the Convention: As a consumer of other modules or     packages, respect the private nature of symbols with leading     underscores and avoid using them directly.</p> </li> </ul>"},{"location":"glossary.html#limitations-and-considerations_1","title":"Limitations and Considerations:","text":"<ul> <li> <p>No Strict Enforcement: Python does not provide a strict     mechanism to enforce private access. The leading underscore is     a convention, not a hard restriction, so external code can still     import and use private symbols. However, doing so is generally     considered bad practice and may lead to compatibility issues if     the internal symbols change in future versions of the module     or package.</p> </li> <li> <p>Not to be Confused with Name Mangling: Double leading     underscores (e.g., <code>__private_var</code>) trigger name mangling in     Python, which alters the name to avoid clashes in subclasses.     This is a separate mechanism and not the same as marking a     symbol as private.</p> </li> </ul> <p>In summary, private imports are a valuable tool in designing clean and maintainable code by defining a clear boundary between public interfaces and internal implementation. They rely on community conventions and developer discipline rather than strict language enforcement.</p>"},{"location":"glossary.html#python-modules","title":"Python Modules","text":"<p>Definition: A module is a single file containing Python code. It can contain functions, variables, classes, and runnable code. Essentially, any Python file with a <code>.py</code> extension is a module.</p> <p>Purpose: Modules are used to organize code into reusable and manageable chunks. By putting related functions and variables into a module, you can import them into other Python files.</p> <p>Example:</p> <p>A file named <code>mymodule.py</code> containing functions and classes related to mathematical operations.</p>"},{"location":"glossary.html#python-packages","title":"Python Packages","text":"<p>Definition: A package is a directory that contains multiple module files and a special <code>__init__.py</code> file. The presence of <code>__init__.py</code> (which can be empty) tells Python that the directory should be considered a package.</p> <p>Purpose: Packages are used to organize multiple modules into a hierarchical namespace. This allows for structuring your code in a way that groups related modules together, making it more maintainable and scalable.</p> <p>Example:</p> <p>A directory named mypackage containing several module files related to different aspects of data processing, and an <code>__init__.py</code> file to signify it as a package.</p>"},{"location":"glossary.html#relative-imports","title":"Relative Imports","text":"<p>Relative imports in Python allow you to import modules or specific objects from modules that are located relative to the current module or package. They make use of dots (<code>.</code>) to indicate the relative path to the desired module within the same package hierarchy.</p> <p>Here's a breakdown of how relative imports work:</p> <ul> <li>A single dot (<code>.</code>) refers to the current package or     directory.</li> <li>Two dots (<code>..</code>) refer to the parent package or     directory.</li> <li>Additional dots (<code>...</code>, <code>....</code>, etc.) refer to     higher-level parent packages or directories.</li> </ul> <p>Example:</p> <p>Consider the following directory structure:</p> <pre><code>my_package/\n\u251c\u2500\u2500 subpackage_a/\n\u2502   \u251c\u2500\u2500 module_a.py\n\u2502   \u2514\u2500\u2500 __init__.py\n\u251c\u2500\u2500 subpackage_b/\n\u2502   \u251c\u2500\u2500 module_b.py\n\u2502   \u2514\u2500\u2500 __init__.py\n\u2514\u2500\u2500 __init__.py\n</code></pre> <p>If you want to import <code>module_a.py</code> from <code>module_b.py</code>, you can use a relative import like this (inside <code>module_b.py</code>):</p> <pre><code>from ..subpackage_a import module_a\n</code></pre>"},{"location":"glossary.html#advantages-of-relative-imports","title":"Advantages of Relative Imports","text":"<ol> <li> <p>Portability: Relative imports make the code more    portable, as they don't rely on the absolute path of    the module. If you move the package to a different    location, the relative imports will still work.</p> </li> <li> <p>Readability: In a well-structured project, relative    imports can make the code more concise and clear by    showing the relationship between modules.</p> </li> </ol>"},{"location":"glossary.html#potential-issues","title":"Potential Issues","text":"<ol> <li> <p>Ambiguity: Without clear context, relative imports    might be less intuitive to understand, especially in a    complex project.</p> </li> <li> <p>Compatibility: Relative imports require the file to    be part of a package (i.e., there must be an    <code>__init__.py</code> file), and they are not meant to be used    in standalone scripts.</p> </li> </ol>"},{"location":"glossary.html#best-practices","title":"Best Practices","text":"<p>While relative imports can be useful, it's essential to use them thoughtfully and consistently. Many projects prefer to use absolute imports for clarity, especially if the package structure is not overly complex. Mixing relative and absolute imports without clear guidelines can lead to confusing code.</p> <p>In Python 3, all imports that start with a dot are considered relative, and attempting to perform a relative import from a script that is not part of a package will result in an ImportError. Therefore, understanding the package structure and following consistent practices is key to using relative imports effectively.</p>"},{"location":"glossary.html#root-package","title":"Root Package","text":"<p>A root package, also referred to as the top-level package, is the main or primary package in a project that serves as the entry point for accessing other modules and packages within the project hierarchy. It is often the package that represents the project's main functionality or encapsulates the entire codebase. The root package can be considered the \"base\" or \"parent\" of all other packages and modules within the project.</p> <p>Definition:</p> <p>The root package is the highest-level package in a project's hierarchy. It often contains the main entry points, key functionalities, or core components of the project. Other packages and modules within the project are typically organized under the root package, either directly or through nested subpackages.</p> <p>Example:</p> <p>Consider a project called <code>MyApp</code> that has the following directory structure:</p> <pre><code>MyApp/\n\u251c\u2500\u2500 my_root_package/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 subpackage_a/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 module_a.py\n\u2502   \u251c\u2500\u2500 subpackage_b/\n\u2502   \u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2502   \u2514\u2500\u2500 module_b.py\n\u2502   \u2514\u2500\u2500 main_module.py\n\u2514\u2500\u2500 setup.py\n</code></pre> <p>In this example, <code>my_root_package</code> is the root package of the project. It serves as the top-level package containing all the other subpackages (<code>subpackage_a</code>, <code>subpackage_b</code>) and modules (<code>main_module.py</code>) within the project. The root package often plays a central role in the project's architecture and dependency management. Accessing functionalities within the project would typically involve importing from this root package.</p>"},{"location":"glossary.html#wildcard-imports","title":"Wildcard Imports","text":"<p>Wildcard imports in Python refer to the practice of importing all symbols (functions, classes, variables, etc.) from a module into the current namespace using the asterisk (<code>*</code>) symbol. This can make all the names defined in the imported module available in the current scope without needing to prefix them with the module name.</p> <p>Here's an example of a wildcard import:</p> <pre><code>from math import *\n</code></pre> <p>After this import, you can directly use functions like <code>sqrt</code>, <code>sin</code>, <code>cos</code>, etc., from the <code>math</code> module without prefixing them with <code>math.</code>.</p>"},{"location":"glossary.html#advantages-of-wildcard-imports","title":"Advantages of Wildcard Imports","text":"<ol> <li>Conciseness: Wildcard imports can make the code    more concise, as you don't need to prefix every call    with the module name or list all the specific names    you want to import.</li> </ol>"},{"location":"glossary.html#disadvantages-and-risks-of-wildcard-imports","title":"Disadvantages and Risks of Wildcard Imports","text":"<ol> <li> <p>Namespace Clashes: If different modules define    symbols with the same name, wildcard imports can lead    to name clashes, potentially overwriting existing names    in the current namespace.</p> </li> <li> <p>Readability and Maintainability: Wildcard imports    can make the code less readable, as it becomes unclear    where a specific symbol comes from. This can make code    maintenance and debugging more challenging.</p> </li> <li> <p>Lack of Control: By importing everything, you may    bring into scope symbols that you don't need or intend    to use, cluttering the namespace.</p> </li> <li> <p>Potential Inefficiency: Importing everything from    a large module might consume more memory or slow down    the loading time, even if you only need a small subset    of the functions or classes.</p> </li> </ol>"},{"location":"glossary.html#best-practices-and-recommendations_4","title":"Best Practices and Recommendations","text":"<p>Wildcard imports are generally discouraged in production code due to the risks and disadvantages mentioned above. Many style guides, such as PEP 8, recommend avoiding wildcard imports and instead explicitly listing the names you want to import. This promotes clarity, maintainability, and reduces the risk of unexpected behavior.</p> <p>If you need to use many symbols from a module, you can import the module itself and then use the module prefix to access its symbols:</p> <pre><code>import math\n\nresult = math.sqrt(16)\n</code></pre> <p>Or, you can explicitly list the symbols you want to import:</p> <pre><code>from math import sqrt, sin, cos\n</code></pre> <p>Both of these approaches provide more control and clarity compared to wildcard imports.</p>"},{"location":"license.html","title":"License","text":"<p>The MIT License (MIT)</p> <p>Copyright (c) 2023 Rodrigo Gonzalez</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"}]}